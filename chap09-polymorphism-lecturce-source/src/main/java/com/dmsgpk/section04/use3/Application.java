package com.dmsgpk.section04.use3;

public class Application {

    /* 상속은 부모 클래스가 가지고 있는 멤버를 자식 클래스가 가지는 의미.

    메소드 재정의(overriding)은 부모가 가지는 메소드 선언부를 그대로 사용하면서
    자식 클래스가 정의한 메소드대로 동작하도록 구현 몸체 {} 부분을 새롭게 다시 작성하는 기술

    메소드 재정의를 하면 메소드를 호출할 때 재정의한 메소드가 우선적으로 동작한다.
    상속할 때 쓰는 키워드는 extends다. 키워드를 사용하고 상속받을 부모 클래스 이름을 적는다.

    메소드 재정의가 제대로 작성됐는지 체크하고 싶다면,
    System.out.println("a1이 Tiger인지 확인 : " + (a1 instanceof Tiger));

    다향성은 하나의 인스턴스(객체)가 여러가지 타입을 가질 수 있는 걸 의미한다

    Animal a1 = new Rabbit();
    Animal a2 = new Tiger();
    -> 부모 타입으로 자식의 인스턴스 주소를 저장했다.

    동적 바인딩이란, 컴파일 당시에는 해당 타입의 메소드와 연결이 되어 있다가
    런타임 할 때 실제 객체가 가진 오버라이딩된 메소드로 바인딩이 바뀌어 동작하는 것.

    a1.cry(); //컴파일 당시에는 animal에 연결이 되어 있다가, 실행하면 rabbit과 연결되는 것

    클래스의 형변환은 up-casting과 down-casting으로 구분할 수 있다.
        * up-casting : 상위 타입으로 형변환 -> 부모 클래스로 형변환
        * down-casting : 하위 타입으로 형변환 -> 자식 클래스로 형변환

    추상메소드를 0개 이상 포함하는 클래스가 추상 클래스
    추상클래스는 클래스 선언부에 abstract 키워드를 명시한다.
    추상 클래스는 인스턴스를 생성할 수 없다.
    // Product product = new Product();

    그래서 추상클래스를 상속받은 하위 클래스를 이용해서 인스턴스를 생성해줘야 한다.
    이 때, 추상 클래스는 상위 타입으로 사용될 수 있으며, 다향성을 이용할 수 있다.

    추상 클래스에 작성한 추상 메소드는 반드시 후손이 오버라이딩 해서 작성해야 한다.

    추상 메소드
        * 메소드의 선언부만 있고 구현부가 없는 메소드
        * 추상메소드의 경우 반드시 abstract 키워드를 메소드 헤드에 작성해야 한다.
        * 예) public abstract void method();

    상속할 때는 extends 를 사용해야 하는데 interface를 상속할 때는 implements를 사용해야 한다.

     */

    public static void main(String[] args) {





    }
}
